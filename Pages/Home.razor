@using AIOrchestrator.Model;
@using Newtonsoft.Json;
@using OpenAI;
@inject NotificationService NotificationService
@inject DialogService DialogService
@inject SettingsService SettingsService
@inject LogService LogService
@inject OrchestratorMethods OrchestratorMethods
@implements IDisposable
<h3>Home</h3>
@if (@InProgress)
{
    <div class="rz-m-10">
        <RadzenProgressBar Value="100" ShowValue="false" Mode="ProgressBarMode.Indeterminate" />
    </div>
}
<!-- Dropdown showing files in the Documents directory -->
<div class="row">
    <div class="col">
        <RadzenLabel><b>Select File:</b></RadzenLabel><RadzenDropDown @bind-Value=@SelectedFile Data=@DocumentFiles TextProperty="Name" ValueProperty="FullName" Style="width: 300px" />
    </div>
</div>
<br />
<RadzenTabs TabPosition=TabPosition.Top RenderMode="TabRenderMode.Client">
    <Tabs>
        <RadzenTabsItem Text="Text">
            <div class="row">
                <div class="col">
                    <RadzenButton Text="Load Text" ButtonStyle="ButtonStyle.Success"
                                  Click="LoadText"
                                  Style="margin-bottom: 10px; width: 150px" />&nbsp;&nbsp;
                </div>
            </div>
            <RadzenTextArea @bind-Value=@TextFileRaw Cols="70" Rows="10" />
        </RadzenTabsItem>
        <RadzenTabsItem Text="SummarizeText">
            <div class="row">
                <div class="col">
                    <RadzenButton Text="Summarize Text" ButtonStyle="ButtonStyle.Info"
                                  Click="SummarizeText"
                                  Style="margin-bottom: 10px; width: 150px" />&nbsp;&nbsp;
                    <RadzenLabel><b>Chunk Size (words):</b></RadzenLabel>&nbsp;&nbsp<RadzenNumeric @bind-Value=@intChunkSize style="width:75px" />
                    &nbsp;&nbsp
                    <RadzenLabel><b>Max Iterations:</b></RadzenLabel>&nbsp;&nbsp<RadzenNumeric @bind-Value=@intMaxLoops style="width:75px" />
                </div>
            </div>
            <RadzenTextArea @bind-Value=@txtSummarizeText Cols="70" Rows="10" />
        </RadzenTabsItem>
    </Tabs>
</RadzenTabs>
@code {
    private string TextFileRaw = "";
    private string txtSummarizeText = "";
    bool InProgress = false;

    List<System.IO.FileInfo> DocumentFiles = new List<System.IO.FileInfo>();
    string SelectedFile { get; set; }

    int intMaxLoops = 3;
    int intChunkSize = 2000;

    protected override void OnInitialized()
    {
        // Get the list of files in the Documents directory
        var DocumentPath = $"{Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments)}\\AIOrchestrator\\Documents";
        var dir = new DirectoryInfo(DocumentPath);
        DocumentFiles = dir.GetFiles().ToList();

        if (DocumentFiles.Count > 0)
        {
            SelectedFile = DocumentFiles[0].FullName;
        }

        OrchestratorMethods.ReadTextEvent += OrchestratorMethods_ReadTextEvent;
    }

    private async Task LoadText()
    {
        try
        {
            InProgress = true;

            // Open the file to get existing content
            using (var streamReader = new StreamReader(SelectedFile))
            {
                TextFileRaw = await streamReader.ReadToEndAsync();
            }

            InProgress = false;
        }
        catch (Exception ex)
        {
            LogService.WriteToLog($"Error: {ex.Message}");

            NotificationService.Notify(new NotificationMessage
                {
                    Severity = NotificationSeverity.Error,
                    Summary = "Error",
                    Detail = ex.Message,
                    Duration = 4000
                });
        }
    }

    private async Task SummarizeText()
    {
        try
        {
            InProgress = true;

            ClearLog();

            txtSummarizeText = await OrchestratorMethods.ReadText(SelectedFile, intMaxLoops, intChunkSize);
            InProgress = false;
        }
        catch (Exception ex)
        {
            LogService.WriteToLog($"Error: {ex.Message}");

            NotificationService.Notify(new NotificationMessage
                {
                    Severity = NotificationSeverity.Error,
                    Summary = "Error",
                    Detail = ex.Message,
                    Duration = 4000
                });
        }
    }

    private void OrchestratorMethods_ReadTextEvent(object sender, EventArgs e)
    {
        ReadTextEventArgs ReadTextEventArguments = (ReadTextEventArgs)e;

        NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Info,
                Summary = "Info",
                Detail = ReadTextEventArguments.Message,
                Duration = 4000
            });
    }

    public void Dispose()
    {
        OrchestratorMethods.ReadTextEvent -= OrchestratorMethods_ReadTextEvent;
    }


    // Utility

    private void ClearLog()
    {
        try
        {
            var AIOrchestratorLogPath = $"{Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments)}/AIOrchestrator/AIOrchestratorLog.csv";

            using (var streamWriter = new StreamWriter(AIOrchestratorLogPath))
            {
                streamWriter.WriteLine(string.Join("\n", "Log cleared on " + DateTime.Now));
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(new NotificationMessage
                {
                    Severity = NotificationSeverity.Error,
                    Summary = "Error",
                    Detail = ex.Message,
                    Duration = 4000
                });
        }
    }
}